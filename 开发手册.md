# 开发手册

## 共识算法

拟采用RPCA作为区块链的共识算法

### 1. RPCA共识算法介绍

#### 1.1 RPCA基本概念

服务节点：就是可以接收交易的节点，包括验证节点和非验证节点，验证节点是指被其他节点加入到信任列表的节点，参与共识过程，非验证节点不参与共识过程

UNL（unique node list）：信任节点列表，每个服务节点都会维护一个信任节点列表，这里的信任并不是我们通常理解的信任，而是指我信任这个列表中的节点不会联合起来作弊。在共识过程中，我们只接受来自信任节点列表中节点的投票。在Ripple中，我们用在配置文件中加入其它验证节点的公钥的方式来指定UNL

#### 1.2. 共识过程

Ripple网络每隔几秒就会产生一个新的区块，这个区块的产生过程就是所有网络节点RPCA共识的过程。假设共识过程是成功的，并且网络中没有分叉产生，那么新生成的区块就是全网唯一的。

RPCA对交易分两个阶段完成，第一阶段是达成交易集的共识，第二阶段是对新生成的区块进行提议，最终形成被共识过的区块。

达成交易集的共识分轮进行，在每一轮中进行下面的操作：

##### 1.2.1 交易共识，形成交易集

1 每个节点在共识开始时尽可能多的收集所能收集到的需要共识的交易，并放到“候选集”里面；

2 每个节点对它信任节点列表中的 “候选集”做一个并集，并对每一个交易进行投票；

3 UNL中的服务节点交流交易的投票结果，达到一定投票比例的交易会进入到下一轮，达不到比例的交易要么被丢弃，要么进入到下一次共识过程的候选集中；

1. 在最终轮中，所有投票超过80%的交易会被放到共识过的交易集中，这里的交易集与比特币类似，也是Merkle树的数据结构。

##### 1.2.2 区块打包，再共识

形成交易集后，每个节点开始打包新的区块，打包区块的过程如下：

1. 把当前区块号、共识交易集的Merkle树根Hash、父区块Hash、当前时间戳等内容放到一起，计算一个区块哈希
2. 每个节点广播自己得出的区块哈希到它可见的节点，这里的可见节点不仅仅指可信列表中的节点，而是通过节点发现过程能发现的节点
3. 节点收集到它所有可信列表中节点广播过来的区块哈希后，结合自己生成的区块哈希，对每个区块哈希计算一个比例，如果某一哈希的比例超过一个阈值（一般是80%），则认识这个哈希是共识通过的区块哈希。如果自己的哈希与之相同，则说明自己打包的区块得到了确认，是新的被共识过的区块，直接存到本地，并且更新状态。如果自己的哈希与共识通过的哈希不同，那就需要去某个区块哈希正确的节点索要新的区块信息，要到之后存储到本地并且更新当前状态。
4. 如果上面没有对某一区块哈希超过设定的阈值，那么重新开始共识过程，直到满足条件。

至此，一个区块的共识过程结束，开启下一轮共识过程。

## 遇到的问题

### 1. RocksDB相关

1.1 利用Rocks DB存储数据，当对某个类型（例如Account）进行修改之后，再把account类型的数据存储进数据库时会发生错误。报的错误是序列化相关问题

出现原因是前后版本不一致，在将byte数组进行反序列化的过程中出现了问题，解决办法将Rocks DB文件夹删除，再进行存储就可以了

1.2 存储account类型的数据时，私钥可以输出，但是存入数据库取出来之后显示为null

出现原因是序列化相关的问题，因为自定义的SKType没有序列化，

1.3 存入Rocks DB的account类型永远只有一条数据

出现原因是因为rocks DB是key-value类型数据库，根据key存储，而设计的account类型的key是wallet_+accountAddress，而account地址是公钥的哈希，之前的地址方法为

```java
account.setAccountAddr(Cryptography.myHash(pk.toString()));
```

其中pk是一个引用类型，是对pk的地址进行哈希，所以得出的值都是一样的，所以只存储了一条数据，解决方法:将account的值进行哈希，问题解决

```java
account.setAccountAddr(Cryptography.myHash(pk.value.toString()));
```

